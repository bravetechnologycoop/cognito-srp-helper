import { BigInteger } from "jsbn";
import { SRPAuthenticationHelper } from "../srp-authentication-helper";

// Client credentials
const USERNAME = "username";
const PASSWORD = "password";
const POOL_ID = "region_123456";

// Server values (generated with the above client credentials, and b = 123456)
const SECRET = "secret";
const SALT = "1234567890abcdef";
const SERVER_SIGNATURE = "kwIHDQhgaEvhSiRrKwMluwp5M/+sk2r6ttDlwrYAQuQ=";
const SERVER_LARGE_B =
  "38964bd8b8d8a178fe983f0a184f7bf574b7650dddae5c28e65593471d1d4cdec34cb8939da30f510adc155af488720943d00c2c035678cf71c423024260ff298d740f90980225d451a71bc1c2fc0470cf607eeb0e650c2d3a99a85b89251172d1be77e791ebaa0df1769f9dc428f3aac5ada6fdd48be67714dec364a539e8cca38fcca440c3da5d365d4dda215eedf592a42ad2d40be9608cb34728dc896119e7f5bbcb9e97e62afc40e10a2aaffbd8de4a8e6b6e525af9bff792ff0fa5b42852af2bf6dd9fcca6b09fefa73ef3ec08f55e3abf3a7ea039b6a9da9e9fcf4c42329546cd9793fd6236d56e08e93f5085b6cbeb364140af8700bc75de8ff15b1a21a952cf752dd823aa2b5d31d0914dbabc5e0c37c80c15dea0242b3848be60276c77e8036a93f445f053429d4968ff6c02ff720f604ae31c455f049e407b2e227960a85e055658445d6288c3a5aff5ec2dde317fff6031828441dd735c3d0caa9cd5972c2c3f5f585fa6fdf35127cfd179c9789de0bfda95b198dee194f4e6284ae1220163cc3072c015c94471ce173f5def81faa48a95078b4b4b4348b95bc9";

// Set value for a when we want output to be deterministic
const CLIENT_SMALL_A = new BigInteger("abcdef", 16);
const TIMESTAMP = "Sun Oct 23 17:02:22 UTC 2022";

describe("getTimeStamp", () => {
  test("Timestamp generated by helper should match the format WEEKDAY MONTH DAY HH:MM:SS UTC YEAR", () => {
    const cognitoTimeStampRegex =
      /(Sun|Mon|Tue|Wed|Thu|Fri|Sat){1} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec){1} [1-3]?[0-9] [0-9]{2}:[0-9]{2}:[0-9]{2} UTC [0-9]{4}/;
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      POOL_ID
    );
    const timestamp = srpAuthenticationHelper.getTimeStamp();
    const matchedRegex = cognitoTimeStampRegex.test(timestamp);
    expect(matchedRegex).toEqual(true);
  });
});

describe("getEphemeralKey", () => {
  test("Generated ephemeral key (SRP_A) should be valid SHA256 hash", () => {
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      POOL_ID
    );
    const sha256Regex = /[A-Fa-f0-9]{64}/;
    const ephemeralKey = srpAuthenticationHelper.getEphemeralKey();
    const matchedRegex = sha256Regex.test(ephemeralKey);
    expect(matchedRegex).toEqual(true);
  });

  test("Successive ephemeral keys (SRP_A) should NOT match", () => {
    const srpAuthenticationHelper1 = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      POOL_ID
    );
    const srpAuthenticationHelper2 = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      POOL_ID
    );
    const ephemeralKey1 = srpAuthenticationHelper1.getEphemeralKey();
    const ephemeralKey2 = srpAuthenticationHelper2.getEphemeralKey();
    expect(ephemeralKey1).not.toEqual(ephemeralKey2);
  });
});

describe("getPasswordSignature", () => {
  // We use constant values for small A and timestamp for deterministic output
  let mockGenerateSmallA: jest.SpyInstance;
  let mockGetNowString: jest.SpyInstance;

  beforeAll(() => {
    mockGenerateSmallA = jest.spyOn(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      SRPAuthenticationHelper.prototype as any,
      "generateSmallA"
    );
    mockGetNowString = jest.spyOn(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      SRPAuthenticationHelper.prototype as any,
      "getNowString"
    );
    mockGenerateSmallA.mockImplementation(() => CLIENT_SMALL_A);
    mockGetNowString.mockImplementation(() => TIMESTAMP);
  });

  afterAll(() => {
    mockGenerateSmallA.mockClear();
    mockGetNowString.mockClear();
  });

  test("Server signature should match client signature when sharing x, and credentials are correct", () => {
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      POOL_ID
    );
    const passwordClaimSignature = srpAuthenticationHelper.getPasswordSignature(
      SERVER_LARGE_B,
      SECRET,
      SALT
    );
    expect(passwordClaimSignature).toEqual(SERVER_SIGNATURE);
  });

  test("Server signature should NOT match client signature when sharing x, and username is incorrect", () => {
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      "wrong_username",
      PASSWORD,
      POOL_ID
    );
    const passwordClaimSignature = srpAuthenticationHelper.getPasswordSignature(
      SERVER_LARGE_B,
      SECRET,
      SALT
    );
    expect(passwordClaimSignature).not.toEqual(SERVER_SIGNATURE);
  });

  test("Server signature should NOT match client signature when sharing x, and password is incorrect", () => {
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      USERNAME,
      "wrong_password",
      POOL_ID
    );
    const passwordClaimSignature = srpAuthenticationHelper.getPasswordSignature(
      SERVER_LARGE_B,
      SECRET,
      SALT
    );
    expect(passwordClaimSignature).not.toEqual(SERVER_SIGNATURE);
  });

  test("Server signature should NOT match client signature when sharing x, and pool ID is incorrect", () => {
    const srpAuthenticationHelper = new SRPAuthenticationHelper(
      USERNAME,
      PASSWORD,
      "wrong_poolid"
    );
    const passwordClaimSignature = srpAuthenticationHelper.getPasswordSignature(
      SERVER_LARGE_B,
      SECRET,
      SALT
    );
    expect(passwordClaimSignature).not.toEqual(SERVER_SIGNATURE);
  });
});
